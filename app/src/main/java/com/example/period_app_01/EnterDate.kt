package com.example.period_app_01

import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.text.KeyboardActions
import androidx.compose.foundation.text.KeyboardOptions
import androidx.compose.material3.Text
import androidx.compose.material3.TextField
import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.collectAsState
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.rememberCoroutineScope
import androidx.compose.ui.focus.FocusRequester
import androidx.compose.ui.focus.focusRequester
import androidx.compose.ui.Modifier
import androidx.compose.ui.platform.LocalSoftwareKeyboardController
import androidx.compose.ui.text.input.ImeAction
import androidx.compose.ui.text.input.KeyboardType
import androidx.compose.ui.text.input.TextFieldValue
import kotlinx.coroutines.launch

import java.time.LocalDate
import java.time.Period
import java.time.format.DateTimeFormatter
import java.time.format.DateTimeParseException
import java.time.temporal.ChronoUnit

import com.example.period_app_01.data.Dates
import com.example.period_app_01.data.DatesDao

@Composable
fun EnterDate(messageDate: String, datesDao: DatesDao) {
    /*
     * state variable, using val to prevent reassignment from TextFieldValue
     * value stored in TextFieldValue itself is mutable
     * mutableStateOf keyword recomposes UI upon value change (e.g. each typed char)
     * remember keyword ensures preservation of state across recompositions
     * what counts as a recomposition?
     */
    val textDate = remember { mutableStateOf(TextFieldValue("")) }
    /*
     * controls the visibility of the keyboard
     * .current to obtain the actual value of the SoftwareKeyboardController
     * current is a property of this type of object
     */
    val keyboardController = LocalSoftwareKeyboardController.current
    // to allow focusing to a particular part of the UI (e.g. keyboard), remember to preserve state
    val focusRequester = remember { FocusRequester() }
    /*
     * tied to the lifecycle of this composable function (see annotation preceding method)
     * essential for launching coroutines within composables
     * i.e. something generated by composable function (e.g. function, UI elements, etc.)
     * coroutines are operations which run on a thread separate from the main one
     * necessary since otherwise, main thread, which handles UI operations, may lag
     * cannot remove, otherwise throws exception preventing database access from main thread
     */
    val coroutineScope = rememberCoroutineScope()
    /*
     * retrieving most recent entry from database
     * even though database is accessed, no need to explicitly launch coroutine
     * since collectAsState method already launches required coroutine
     * method takes Flow from database, a data stream automatically refreshed when updated
     * method converts Flow to state object, which can then be used in the main thread
     * initially, the state is null, as the database row is empty
     */
    val lastEntry: Dates? by datesDao.getLastEntry().collectAsState(initial = null)
    /*
     * extracting values from the above state object, rather than collecting their states separately
     * more efficient that running three extra coroutines
     */
    val lastIdEntry: Int? = lastEntry?.id
    val lastPeriodEntry: Long? = lastEntry?.period
    val lastDateEntry: LocalDate? = lastEntry?.date
    /*
     * specifying date format, from the user, which will be accepted by the TextFieldValue
     * not using value from resources since too complicated within composable function (ask Gemini)
     */
    val formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd")

    // organizing elements into a column, so that they don't overlap, primitive UI so empty constructor
    Column {
        // TextField can have many more parameters, but some were breaking the functionality
        TextField(
            // retrieving value from state variable
            value = textDate.value,
            //
            onValueChange = { textDate.value = it},
            //
            placeholder = { Text(messageDate) },
            // restricting input to a single line
            singleLine = true,
            keyboardOptions = KeyboardOptions(
                // keyboard on screen only has numbers
                keyboardType = KeyboardType.Number,
                // action performed by keyboard, changes icon accordingly
                imeAction = ImeAction.Done
            ),
            keyboardActions = KeyboardActions(
                // actions performed when pressing the checkmark on the keyboard
                onDone = {
                    // makes the keyboard disappear
                    keyboardController?.hide()
                    // retrieve the value from the TextField
                    val text = textDate.value.text
                    // conditions (need to be improved in order to protect from invalid inputs)
                    // delete previous date if database is not empty

                    coroutineScope.launch {
                        if (text == "0000-00-00" && lastEntry != null) {
                            datesDao.deleteLast()
                        //
                        } else if (text != "0000-00-00" && lastEntry == null) {
                            //
                            try {
                                val stringToDate: LocalDate? = LocalDate.parse(text, formatter)
                                val newDate = Dates(
                                    id = 0,
                                    date = stringToDate,
                                    period = 0
                                )
                                //
                                datesDao.insert(newDate)
                            } catch(exception: DateTimeParseException) {
                                run {}
                            }
                        } else {
                            //
                            try {
                                val stringToDate: LocalDate? = LocalDate.parse(text, formatter)
                                //
                                val newDate = Dates(
                                    id = lastIdEntry?.plus(1),
                                    date = stringToDate,
                                    // between method for Period does not work if exceeding one month, since days reset to 0
                                    period = lastPeriodEntry?.plus(ChronoUnit.DAYS.between(lastDateEntry, stringToDate))
                                    // period = lastPeriodEntry + ChronoUnit.DAYS.between(lastDateEntry, stringToDate)
                                )
                                //
                                datesDao.insert(newDate)
                            } catch (exception: DateTimeParseException) {
                                run {}
                            }
                        }
                    }
                    // reset the field
                    textDate.value = TextFieldValue("")
                    //
                    keyboardController?.show()
                    //
                    focusRequester.requestFocus()
                }
            ),
            modifier = Modifier.focusRequester(focusRequester)
        )
        //
        lastEntry?.let {
            Text(text = "Last period date: ${it.date}")
        }

        if (lastIdEntry != 0) {
            /*
            * long value, therefore loses precision which affects accuracy of predictions
            * lastPeriodEntry is sum of all periods, lastIdEntry is total rows in table minus 1
            */
            val averagePeriod = lastPeriodEntry?.div(lastIdEntry!!)
            // val averagePeriod = lastPeriodEntry / lastIdEntry
            /*
            * using method from time library to add days to most recent period date
            * converting averagePeriod to integers since method does not take long value
            */
            val nextPeriodDate = lastDateEntry?.plus(Period.ofDays(averagePeriod!!.toInt()))
            //val nextPeriodDate = lastDateEntry?.plus(Period.ofDays(averagePeriod.toInt()))

            if (lastEntry != null) {
                Text(text = "Next period date: $nextPeriodDate")
            }
        }
    }
    LaunchedEffect(Unit) {
        focusRequester.requestFocus()
        keyboardController?.show()
    }
}